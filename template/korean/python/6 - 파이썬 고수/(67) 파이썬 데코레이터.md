# @property

다음과 같은 클래스를 만들어 보겠습니다.

```
class Teacher:
  def __init__(self, name, subjectTeaching):
    self.name = name
    self.subjectTeaching = subjectTeaching

  def name(self):
    return self.name
```

위의 클래스에서 선생님의 이름을 알기 위하여 `name()`을 사용해야 합니다.

하지만 @property를 사용한다면 `name`을 사용할 수 있습니다.

그래서 이 코드를 함수 앞에 넣으면 그 함수는 이제 클래스에서 변수가 됩니다.

클래스의 함수

```
@property
def name(self):
    return self.name
```

그리고 그 값을 바꿀 수도 있습니다.

클래스의 함수

```
@name.setter #name 함수의 값을 정하는 새로운 함수를 만들겠습니다.
def name(self, val):
  self.name = val
```

다음과 같은 코드를 실행할 수 있습니다.

```
myFavTeacher = Teacher("MR JAY")
print(myFavTeacher.name)
myFavTeacher.name = 'MS GOULD'
print(myFavTeacher.name)
```

또 값을 지울 수도 있습니다.

클래스의 함수

```
@name.deleter
def name(self, val):
  print('삭제하겠습니다….)

  def self.name
```

# @classmethod

클래스 값을 메서드로 바꿀 수도 있습니다. 하지만 이 코드 뒤에 나오는 함수에서 self는 항상 `__init__()` 밖에 있는 변수들입니다.

그래서 `__init__()` 안에 있는 변수는 다음 함수에서 존재하지 않습니다.

```
class Teacher:
  name = "?"
  def __init__(self, age):
    self.age = age

  @classmethod
  def getName(self):
    print(self.name)
```

# @staticmethod

다음에 나오는 함수는 클래스 안에서만 함수 또는 변수를 사용할 수 있습니다.

만일 클래스 밖에서 사용했다면 에러가 생길 것입니다.

```
class Teacher:
  name = "?"
  def __init__(self, age):
    self.age = age

  @staticmethod
  def getName(self):
    print(self.name)
```
