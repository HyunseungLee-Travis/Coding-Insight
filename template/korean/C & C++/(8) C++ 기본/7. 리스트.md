# vector와 리스트

vector는 가장 자리를 바꾸는 것이 매우 복잡하고 어렵습니다.

그 이유는 vector는 쌓아올리는 데이터 형태이기 때문에 모든 데이터를 움직여야 하기 때문입니다.

하지만 list라는 데이터 형태를 사용하면 매우 쉬워집니다.

```
#include <iostream>
#include <list>
using namespace std;

int main()
{
  list <int> firstList{1, 2, 3};
  list <int> secondList = {1, 2, 3};

  return 0;
}
```

# insert() 메서드

insert() 메서드는 어떤 인덱스(자리)에 새로운 값을 추가합니다.

처음에는 리스트 이터러블을 넣습니다. (list.begin() + 원하는인덱스)
다음, 아이템을 입력합니다.

```
#include <iostream>
#include <list>
using namespace std;

int main()
{
  list<int> main{1, 2, 3};

  main.insert(main.begin(), 2);  for(list<int>::iterator itr=main.begin();main!=li.end();++itr)
    cout<<*itr;

  return 0;
}
```

참고로 list<int>::iterator은 리스트를 저장할 수 있는 변수입니다.

# push_back()과 push_front()

push_back()은 끝에 붙이고 push_front()는 처음에 넣습니다.

```
#include <iostream>
#include <list>
using namespace std;

int main()
{
  list<int> main{1, 2, 3};

  main.push_back(4);
  main.push_front(0);  for(list<int>::iterator itr=main.begin();main!=li.end();++itr)
    cout<<*itr;

  return 0;
}
```

# pop_back()과 pop_front()

비슷하게, pop_back()은 마지막을 삭제하고 pop_front()는 처음을 삭제합니다.

```
#include <iostream>
#include <list>
using namespace std;

int main()
{
  list<int> main{1, 2, 3};

  main.pop_back();
  main.pop_front();  for(list<int>::iterator itr=main.begin();main!=li.end();++itr)
    cout<<*itr;

  return 0;
}
```

# empty()와 size()
empty()는 리스트가 비어있는지 확인하는 메서드입니다.

size()는 리스트에 얼마나 많은 아이템의 수를 돌려줍니다.

```
#include <iostream>
#include <list>
using namespace std;

int main()
{
  list<int> main{1, 2, 3};

  main.pop_back();
  main.pop_front();

  cout << main.size();

  if (main.empty()) {
    cout << "\n리스트는 비어있습니다\n";
  } else {
    cout << "\n리스트는 비어 있지 않습니다\n";
  }

  return 0;
}
```
