# 던더?
클래스 시간에 __변수이름 형태인 클래스 변수를 배웠습니다. 파이썬에서 __는 던더라고 합니다. 이번 시간에는 다양한 던더 메서드에 대하여 배우겠습니다.

# `__str__()` and `__repr__()`
내용이 없는 클래스를 만들겠습니다.

```
class Person:
  pass

a = Person()
```

그리고 Person을 출력하겠습니다.

```
print(a)
```

하지만 `<class '__main__.Person'>`만 출력이 됩니다. 하지만 Person 클래스 자체를 출력할때 특정한 문자를 돌려줄 수 있습니다.

```
class Person:
  def __init__(self, name):
    self.name = name

  def __str__(self):
    return "A person named " + self.name
```

이제 Person 클래스를 만들고 변수를 출력하면 `A person named <Name>`이 출력이 됩니다.

하지만 아직 eval(배울내용입니다.)을 사용하면 또 이해할 수 없는 문자가 출력이 됩니다. 이 문제는 `__repr__`로 해결이 가능합니다.

```
class Person:
  def __init__(self, name):
    self.name = name

  def __str__(self):
    return "__str__"

  def __repr__(self):
    return "__repr__"
```

# `__del__()`
클래스를 사제하려면 del 키워드를 사용할 수 있습니다. 파이썬에서 만일 어떤 클래스가 삭제되면 실행할 수 있는 코드를 담을 수 있는 미리 선언된 `__del__()` 함수가 있습니다.

```
class Person
  def __init__(self, name):
      self.name = name

  def __del__(self):
    print("Data was deleted: " + self.name)

me = Person()
del me
```

# `__new__()`
new는 새롭다라는 뜻으로 파이썬에서는 클래스가 만들어졌을때 실행이 되는 코드를 담은 던더 메서드입니다.

하지만 꼭 new 던더 메서드에 매개변수로 cls를 입력해야합니다.

```
def Testing:
  def __new__():
    print("I am created by you!")

a = Testing()
```

"I am created by you!"가 출력이 됩니다.

# `__mul__()`
아주 재미있는 던더 메서드입니다. 함수를 변수에 저장하고 그 변수에 값을 곱하는 것은 원래 불가능해야하지만 `__mul__()`을 사용하면 수월하게 실행시키는 것이 가능합니다.

```
class Person:
  def __init__(self, name):
    self.name = name

  def __repr__(self):
    return self.name

  def __mul__(self, x):
    if type(x) is not int:
      raise Exception("Should be an integer...")

    self.name *= x


me = Person("Hyunseung")
me * 5
print(me)
```

먼저, Person 클래스의 이름 변수를 만들었습니다. 다음에, 변수 값 그 자체로 클래스의 값을 찾을 수 있게 repr 던더 메서드를 만들었습니다. 마지막으로 mul 던더 메서드를 사용하며 만일 x의 값이 숫자가 아니면 에로를 만들고 맞다면 클래스의 이름에다 x를 곱했습니다.

# `__call__()`
call을 사용하면 클래스가 함수처럼 실행이되면 어떤 코드를 런할 수 있는 던더 메서드입니다.

```
class Person:
  def __init__(self, name):
    self.name = name

  def __repr__(self):
    return self.name

  def __mul__(self, x):
    if type(x) is not int:
      raise Exception("Should be an integer...")

    self.name *= x

  def __call__(self):
    print(self.name)


me = Person("Hyunseung")
me * 5
me()
```

# `__len__()`
만일 len 던더 메서드가 len(클래스)할때 실행이 되는 코드라면 맞습니다!

```
class Person:
  def __init__(self, name):
    self.name = name

  def __repr__(self):
    return self.name

  def __mul__(self, x):
    if type(x) is not int:
      raise Exception("Should be an integer...")

    self.name *= x

  def __call__(self):
    print(self.name)

  def __len__(self):
    return len(self.name)


me = Person("Hyunseung")
me * 5
me()
print(len(me))
```

# 숫자 던더 메서드
```
__neg__()
__pos__()
__abs__()
__invert__() #- 또는 + 또는 ~
__complex__()
__int__()
__float__()
__index__()
__round__()
__trunc__()
__floor__()
__ceil__()
```

위의 던더 메서드는 __없는 함수가 클래스에 실행이 될때 따로 나만의 코드를 실행할 수 있게 해주는 던더 메서드입니다.

# 연산자 던더 메서드
```
__radd__(self, a) # +
__rsub__(self, a) # -
__rmul__(self, a) # *
__rtruediv__(self, a) # /
__rfloordiv__(self, a) # //
__rmod__(self, a) # %
__rpow__(self, a) # pow()

__iadd__(self, a) # 클래스+=a
__isub__(self, a) # -=
__imul__(self, a) # *=
__itruediv__(self, a) # /=
__ifloordiv__(self, a) # //=
__imod__(self, a) # %=
__ipow__(self, other) # **=

__lt__(self, other) # <=
__le__(self, other) # <
__eq__(self, other) # ==
__ne__(self, other) # !=
__gt__(self, other) # >
__ge__(self, other) # >=
```

첫 번째는 self이고 두 번째는 클래스 + 연산자 + x형태에서 x입니다.

# 더다양한 던더 메서드
```
__contains__(self, ITEM)
__reversed__(self)
__iter__(self)
__missing__(self, key) # __getitem__()에서 키가 없다
__delitem__(self, key) # del dict[key]가 실행이 되면
__dir__(self, key)
__delattr__(self, name)
__setattr__(self, name, value)
__getattribute__(self, name)
__bool__(self)
```
