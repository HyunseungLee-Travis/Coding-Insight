# 정규식이란
정규식은 프로그래밍에서 특정한 규칙을 가진 문자열의 집합을 뜻합니다.

정규식 없이 영어에서 모든 알파벳의 문자를 만들고 싶다면 'abcdef...' 하나하나 다 코드 안에 쳐야합니다.

하지만 정규식을 사용하면 아주 간단합니다.

정규식은 모듈이어서 먼저 가지고 와야 합니다.

```
import re #영어로 Regular Expression입니다. (re)
```

# 정규식 - 문자의 값 맞히기
re.match() 메서드를 사용하면 어떤 두 문자에서 같은 시작 부분을 알 수 있습니다.

```
import re

pattern = "123"
string = "123abc"

print(re.match(pattern, string).group())
```

# 정규식 - 문자의 값 찾기
match는 문자의 시작 부분을 알 수 있지만 re.search() 메서드를 사용한다면 전체 값에서의 같은 부분을 계산할 수 있습니다.

```
import re

pattern = "123"
string = "123abc"

print(re.match(pattern, string).group())
```

# Flag
Flag는 어떻게 찾고 맞추는지 입력할 수 있는 매개변수입니다.

```
import re

pattern = "abc"
string = "123abc"

print(re.match(pattern, string, flags=re.IGNORECASE).group())
```

re.IGNORECASE를 사용한다면 string이 123ABC 또는 123Abc 등 대문자인지 소문자인지 상관이 없다를 뜻합니다.

re.DOTALL은 .에서 새로운 줄도 포함합니다.

# 대신하기
re.sub() 메서드는 어떤 문자에서 패턴을 다른 텍스트로 바꾸는 역할을 합니다.

```
import re

print(re.sub("[a-c]", "aORbORc", "Alien is coming!"))
```

두 번째 매개변수에 함수를 넣어서 원래 값을 알 수도 있습니다.

```
import re

print(re.sub("[a-c]", lambda x: x + "!", "Alien is coming"))
```

lambda 익명 함수 안에 첫 번째 매개변수가 원래 값입니다.

이름은 아무것으로 정할 수 있습니다.

그 이유는 이 함수가 실행이 될 때 첫 번째 매개면수에 원래 값을 집어넣고 돌아오는 값을 대신하기 때문에 상관이 없습니다.

# 정규식 캐릭터
[] -- 알파벳의 범위: `"[a-e]"`는 a, b, c, d, e입니다.
 1. `[a-b]`
  2. `[abc]`: a, b, 또는 c
  3. `[^abc]`: a, b, c 제외
. -- 임의의 알파벳: `"h."`는 ha, hb, hc, ... hz 다입니다.
^ -- 단어 중 다음 패턴으로 시작하는지: `"^hello"`: hello로 시작하는 단어가 있는지
$ -- 단어 중 다음 패턴으로 끝나는지: `"$hello"`: hello로 끝나는 단어가 있는지

