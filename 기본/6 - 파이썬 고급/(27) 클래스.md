# 클래스란?
여러분, 어떤 템플릿 파일을 여러번 복사 후 그 새로운 파일만 바꾸고 다음에는 또 새로운 것만 바꾸고 계속 이 과정을 거쳐 수많은 파일을 만든 적이 있나요? 클래스는 처음에 템플릿 파일과 비슷합니다.

클래스라는 것은 어떤 물건을 여러번 효율적으로 만들 수 있게 합니다. 예를 들어서 우리가 어떤 자동차에 대한 정보를 만들고 싶다면 클래스를 만들어서 무수히 많이 사용할 수 있습니다.

```
class MyCar:
  model_name = "QWE_123"
  year = "2021"
```

이제 이 자동차에 대한 정보를 얻기 위하여 MyCar()라고 오브젝트를 만들 수 있습니다.

```
myCar = MayCar()
print(myCar.model_name) #QWE_123
```

# \_\_init\_\_()
위와 같은 예시는 딕셔너리와 같습니다. 하지만 진짜 클래스를 만들기 위해서 \_\_init\_\_() 함수를 사용할 수 있습니다. 우리가 그 클래스를 사용하기 위하여 MyCar()이라고 변수에 저장했습니다. 하지만 이제 \_\_init\_\_() 함수를 사용하면 변수를 만들때 마다 함수처럼 대개변수를 선언할 수 있습니다.

```
class Person:
  def __init__(self, name, age, gender):
    self.name = name
    self.age = age
    self.gender = gender

p1 = Person("Hyunseung", 12, "Male")

print(p1.name)
```

먼저, 클래스 안에서 def \_\_ini\_\_()이라고 선언한 후 안에 self, name, age, gender 변수를 만들었습니다. self는 항상 첫 번째에 있어야 합니다.

init 함수 안에 sef.name = name 같이 p1.name이라고 할때 사용하는 값입니다. 그래서 우리가 Person()을 선언할때 첫 번째 값은 name입니다. name의 값을 알기 위해서 p1.name을 사용했습니다.

# 클래스 안에 함수
클래스 안에서 함수를 선언하면 항상 그 클래스를 사용할때 이미 정해진 함수를 쉽게 다룰 수 있습니다. 만일 우리가 Person 클래스에서 그 사람의 이름을 출력하는 함수를 만들기 위해 Person 클래스 안에 새로운 함수를 만들겠습니다. Self 대개변수는 항상 있어야 합니다. 그 이유는 처음에 선언된 값들이 다 Self 안에 저장되어 있기 때문입니다. 이름 'Hyunseung'은 self 안에 딕셔너리와 비슷하게 있어서 self.name을 사용하여 값을 찾을 수 있습니다.

```
class Person:
  def __init__(self, name, age, gender):
    self.name = name
    self.age = age
    self.gender = gender

  def printTheName(self):
    print(self.name)

p1 = Person("Hyunseung", 12, "Male")

p1.printTheName()
```

# self (자신!)
self는 영어로 '자신'을 뜻합니다. 다시 말해 클래스가 만들어질때 모든 정보를 다 self 안에 저장합니다. 하지만 처음에 init 메서드에는 self 대신 abc, python, class 등 원하는 이름을 사용할 수 있습니다. 단, init 함수와 모든 클래스에 있는 함수는 다 첫 번째 대개변수가 self의 이름이어야 합니다.

```
class Person:
  def __init__(python_class, name, age, gender):
    python_class.name = name
    python_class.age = age
    python_class.gender = gender

  def printTheName(abc):
    print(abc.name)

p1 = Person("Hyunseung", 12, "Male")

p1.printTheName()
```

# 계승
아마도 여러분의 부모님이 돌아가시면 모든 재산은 다 여러분 것이 될 수 있습니다. 이 것을 계승이라고 합니다. 무언 가를 물려받습니다. 클래스에서도 클래스와 클래스끼리 서로 함수와 변수를 주고 받을 수 있습니다.

```
class Person:
  def __init__(python_class, name, age, gender):
    python_class.name = name
    python_class.age = age
    python_class.gender = gender

  def printTheName(abc):
    print(abc.name)

class Student(Person):
  def __init__(python_class, grade):
    python_class.grade = grade

  def printTheGrade(self):
    print(self.grade)
```

하지만 우리가 Student 클래스에서 init 메서드를 선언했습니다. 이 선언한 값은 다 Person 클래스에서 name, age, 그리고 gender 값이 다 없어집니다. 이를 방지하기 위하여 `Person.__init__(python_class, name, age, gender)`를 init 메서드 안에 넣을 수 있습니다.

```
class Person:
  def __init__(python_class, name, age, gender):
    python_class.name = name
    python_class.age = age
    python_class.gender = gender

  def printTheName(abc):
    print(abc.name)

class Student(Person):
  def __init__(python_class, grade, name, age, gender): #init의 대개변수에도 넣습니다.
    Person.__init__(python_class, name, age, gender)
    python_class.grade = grade

  def printTheGrade(self):
    print(self.grade)
```

하지만 super() 함수를 이용하면 매우 더 편리할 수 있습니다.

```
class Student(Person):
  def __init__(python_class, grade, name, age, gender): #init의 대개변수에도 넣습니다.
    super().__init__(python_class, name, age, gender)
    python_class.grade = grade

  def printTheGrade(self):
    print(self.grade)
```

# @mydecorator
우리는 항상 클래스 안에서 대개변수가 없는 함수를 만들기 위하여 'self' 대개변수를 어쩔 수 없이 만들어야 합니다. 하지만 이 불편함을 피할 수 있는 방법이 있습니다.

```
class Student(Person):
  def __init__(python_class, grade, name, age, gender): #init의 대개변수에도 넣습니다.
    super().__init__(python_class, name, age, gender)
    python_class.grade = grade

  def printTheGrade(self):
    print(self.grade)

  def mydecorator(functionToRun):
    def mainFunction():
      functionToRun()
    return mainFunction

  @mydecorator
  def sayHello():
    print("Hello")
```

하지만 우리만의 decorator을 만들어야합니다. 위의 예시에서 mydecorator는 먼저 functionToRun을 실행 후 바로 끝나게 되어있습니다. 원한다면 mydecorator 다응메 나오는 함수를 실행 후 또는 전에 어떤 코드를 실행하고 싶다면 다음과 같은 방법을 사용할 수 있습니다.

```
def mydecorator(functionToRun):
  def mainFunction():
    print("함수 실행 전")
    functionToRun()
    print("함수 실행 후")
  return mainFunction()
```

# @property
다음과 같은 클래스가 있습니다.

```
class Teacher:
  def __init__(self, name, subjectTeaching):
    self.name = name
    self.subjectTeaching = subjectTeaching

  def name(self):
    return self.name
```

위의 클래스에서 선생님의 이름을 알기 위하여 `name()`을 사용해야 합니다. 하지만 @property를 사용한다면 `name`을 사용할 수 있습니다. 다시 말해, property는 값을 뜻합니다. 그래서 이 코드를 함수 전에 넣으면 그 함수는 이제 클래스에서 값이 됩니다.

클래스의 함수
```
@property
def name(self):
    return self.name
```

그리고 그 값을 바꿀 수도 있습니다.

클래스의 함수
```
@name.setter #name 함수의 값을 정하는 새로운 함수를 만들겠다
def name(self, val):
  self.name = val
```

다음과 같은 코드를 실행할 수 있습니다.

```
myFavTeacher = Teacher("MR JAY")
print(myFavTeacher.name)
myFavTeacher.name = 'MS GOULD'
print(myFavTeacher.name)
```

마지막으로 값을 지울 수도 있습니다.

클래스의 함수
```
@name.deleter
def name(self, val):
  print('삭제하겠습니다...')
  def self.name
```

# @classmethod
클래스 값을 메서드로 바꿀 수도 있습니다. 하지만 이 코드 뒤에 나오는 함수에서 self는 항상 `__init__()` 밖에 있는 변수들입니다. 그래서 `__init__()` 안에 있는 변수는 다음 함수에서는 존재하지 않습니다.

```
class Teacher:
  name = "?"
  def __init__(self, age):
    self.age = age

  @classmethod
  def getName(self):
    print(self.name)
```

# @staticmethod
다음에 나오는 함수는 항상 값을 찾을 수 없습니다.

```
class Teacher:
  name = "?"
  def __init__(self, age):
    self.age = age

  @staticmethod
  def getName(self):
    print(self.name)
```

1. 에러
